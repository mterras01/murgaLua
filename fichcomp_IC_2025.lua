--#!/bin/murgaLua
--objectifs du script: correctif des N° de séjours non conformes du FICHCOMP Isolement/contention
---- remplacer le N° de séjour non conforme par le N° de séjour conforme 
---- Si et Seulement Si le N° de mesure correspond à la mesure à corriger
-- AUTEUR MT
--[[ FORMAT FICHCOMP_IC_2025
Libellé	       Taille	     Début	   Fin	     Type de données	     Précision (type de données)	        Caractère obligatoire	Cadrage/ Remplissage
_________________________________________________________________________________________________________________________________________
N° FINESS	     9	      1	       9	     A	                             Référentiel FINESS e-PMSI (Plage)
N° Format	     2	      10	       11	     A	                             Valeur fixe
N° séjour	        20	  12	       31	     A*		                                                                            O	                                Gauche/Espace
N° séquence     7	      32	       38	     A*		                                                                            O	                                Gauche/Espace
Type IC	             1	      39	       39	     A	                             Liste
Date debseq     8	      40	       47	     Date	                     JJMMAAAA
Heure débseq   4	      48	       51	     Date	                     HHmm (24h)
Date finseq       8	      52	       59	     Date	                     JJMMAAAA
Heure finseq     4	      60	       63	     Date	                     HHmm (24h)
Num mesure	 7	      64	       70	     A*		                                                                             O	                                Gauche/Espace
Type mesure	 1	      71	       71	     A	                             Liste
Date debmes    8       72	       79	     Date	                     JJMMAAAA
Heure debmes  4	       80	       83	     Date	                     HHmm (24h)
Date finmes      8	       84	       91	     Date	                     JJMMAAAA
Heure finmes    4	       92	       95	     Date	                     HHmm (24h)
]]--
finess=""
num_format=""
num_sejour={}
num_mesure={}
line_fc={}
line_corr={}

--[[ FORMAT COMPOSANTS CORRECTIFS (CSV avec separateur point-virgule), exporté en xls depuis HM, converti en CSV (;) depuis Excel
DATE_ANALYSE;NIPP;NUMERO_MESURE;NUMSEJ_NON_CONF;TYPE_SEJNC;UNITE_NON_CONF;BORNES_MES;SEJOUR_H_CONFORME;PATIENT_NON_CONFORME;NOM_EXE_DYN
]]--
separator_CSV=";"
num_mesure_corr={}
num_sejour_corr={}
num_sejour_conforme={}
line=""


size_eol=0
read_buffer="" --buffer fichcomp original
read_buffer_corr="" --buffer correctifs
read_buffer_w="" --buffer fichcomp corrigé

find = string.find
sub = string.sub
gsub = string.gsub

function get_date()
  local wd;
  daymonth = tonumber(os.date("%d")); --01 to 31
  month = tonumber(os.date("%m")); --01 to 12
  year = os.date("%Y"); --full 4-digits year
end --end function

function define_textfile_origin(data)
  local i,st

  --finding if -CURRENTLY OPENED- text file
  -- is Unix or Windows -generated
  --searching for CR/LF (windows)
  st = string.char(13) .. string.char(10)
  i = find(data, st)
  if i then
print("file generated by MS Windows => size_eol=2")
     size_eol=2 -- for windows remove CR+LF at end of line
     return("windows")
  else
print("file generated by an Unix-like OS => size_eol=1")
     size_eol=1 -- for unixes remove only LF(?)
     return("unix")
  end
end --end function

function correctifs()
 --remplacer num_sejour_corr[] dans chaque ligne contenant num_mesure_corr[] et num_sejour_corr[] par num_sejour_conforme[]
 local line_rep=""
 local nbremplace=0
 local n,m,p
 
 for i=1,#line_fc do
	 line_rep = line_fc[ i ] --par defaut
     for j=1,#num_mesure_corr do
	     n=num_mesure_corr[ j ] .. ""
	     if find(line_fc[ i ],n) then
print("Numero mesure trouve " .. num_mesure_corr[ j ])
            m=num_sejour_corr[ j ] .. ""
		    if find(line_fc[ i ], m) then
			   p=num_sejour_conforme[ j ] .. ""
		       line_rep = gsub(line_fc[ i ], m, p)
			   nbremplace=nbremplace+1
			   break
		    end
		 end
	 end
     read_buffer_w = read_buffer_w .. line_rep .. "\n"
 end 
 print("nb de remplacements de sejours dans le FICHCOMP IC original = " .. nbremplace)
end --end function

function save_modifs()
  local f
  local i1,i2,st1,st2
  local filename_final=""

  filename_final = filenamefc .. "_CORRECTIFS_MTLua.txt"
  print("fichier FICHCOMP avec correctifs = " .. filename_final)
  
  print("Taille read_buffer_w = " .. #read_buffer_w)
  
  if read_buffer_w then
     if #read_buffer_w > 50 then
        --OK
     else
        --no data to be saved
        return
     end
  else
    --no data to be saved
    return
  end

  f = io.open(filename_final,"wb")
  if f then
     f:write(read_buffer_w)
     io.close(f)
     print("Les correctifs on ete exportés dans le fichier " .. filename_final .. " au format txt avec succes !")
  end
  return filename_final
end --end function

--Fl:scheme("gtk+");
osName = ""
osName=murgaLua.getHostOsName()
print("osName = " .. osName)
get_date()


 --chargement des deux fichiers FICHCOMP IC original (fabriqué par HM) et "composants des correctifs FICHCOMP_IC" exporté depuis LT
 --chargement FICHCOMP IC 
  filenamefc = fltk.fl_file_chooser("SELECTION du FICHIER FICHCOMP Isolement Contention (TXT)", "TXT Files (*.{txt,TXT})", SINGLE, nil)
  ---compute path for corrected file=same path as original file
  print("fichier = " .. filenamefc .. ", taille = " .. #filenamefc)
  j=nil
  pathseparator=""
  if osName == "windows" then
     pathseparator="\\"
  else
     pathseparator="/"
  end
  
  for i=#filenamefc,1,-1 do
  --print("filename[" .. i .. "] = " .. sub(filename, i, i))
      if sub(filenamefc, i, i) == "pathseparator" then
         j = i
--print("/ en position " .. j)
	     break
	  end
  end
  if j then 
     pathfc = sub(filenamefc,1,j)
	 print("pathfc = " .. pathfc)
  end
  
   filenamecorr = fltk.fl_file_chooser("SELECTION du FICHIER des correctifs du FICHCOMP Isolement Contention (CSV)", "CSV Files (*.{csv,CSV})", SINGLE, nil)
  ---compute path for corrected file=same path as original file
  print("fichier = " .. filenamecorr .. ", taille = " .. #filenamecorr)
  j=nil
  for i=#filenamecorr,1,-1 do
      if sub(filenamecorr, i, i) == "pathseparator" then
         j = i
	     break
	  end
  end
  if j then 
     pathcorr = sub(filenamecorr,1,j)
	 print("pathcorr = " .. pathcorr)
  end
  
  
  
--chargement FICHCOMP IC original à corriger
read_buffer = ""
read_buffer_w=""
f = io.open(filenamefc,"rb")
     if f then
        read_buffer = f:read("*all")
        io.close(f)
        st = filenamefc .. " a ete ouvert/enregistre dans le tampon avec succes ! (" .. #read_buffer .. " octets)"
		fltk:fl_alert(st)
     else
       st=filenamefc .. " n'a pas pu etre lu !!! "
	   fltk:fl_alert(st)
       exit(0)
     end
--define_textfile_origin(read_buffer)

 p0=1
 while 1 do
       p = find(read_buffer, "\n", p0, true)
       if p then
          table.insert(line_fc, sub(read_buffer, p0, p-1) )
          finess = sub(line_fc[ #line_fc ], 1, 9)
		  num_format = sub(line_fc[ #line_fc ], 10, 11)
		  if finess and num_format then
--print("Finess=" .. finess .. ", numformat=" .. num_format)
          end
	      table.insert(num_sejour, sub(line_fc[ #line_fc ], 12, 31) )
	      table.insert(num_mesure, sub(line_fc[ #line_fc ], 64, 70) )
	      --p0 = p+size_eol
		  p0 = p+1
       else
	      break
       end
 end
 print(" tables construites pour le FICHCOMP IC original.")
 
 --chargement correctifs FICHCOMP IC : ATTENTION: fichier avec première ligne=légendes des colonnes
read_buffer_corr = ""
f = io.open(filenamecorr,"rb")
     if f then
	    read_buffer_corr = f:read("*line") --chargement factice de la ligne de légende (sera écrasée dans le tampon par la ligne suivante)
        read_buffer_corr = f:read("*all")
        io.close(f)
        st = filenamecorr .. " a ete ouvert/enregistre dans le tampon avec succes ! (" .. #read_buffer_corr .. " octets)"
		fltk:fl_alert(st)
     else
       st=filenamecorr .. " n'a pas pu etre lu !!! "
	   fltk:fl_alert(st)
       exit(0)
     end
--define_textfile_origin(read_buffer_corr)
 p0=1
 nmc=""
 nscr=""
 nsconf=""
 nmc_old=""
 while 1 do
       p = find(read_buffer_corr, "\n", p0, true)
       if p then
	      line=sub(read_buffer_corr, p0, p-1)
		  s1=find(line, separator_CSV, 1)
		  if s1 then
		     s2=find(line, separator_CSV, s1+1)
		  end
		  if s2 then
		     s3=find(line, separator_CSV, s2+1)
		  end
		  if s3 then
		     s4=find(line, separator_CSV, s3+1)
		  end
		  if s4 then
		     s5=find(line, separator_CSV, s4+1)
		  end
		  if s5 then
		     s6=find(line, separator_CSV, s5+1)
		  end
		  if s6 then
		     s7=find(line, separator_CSV, s6+1)
		  end
		  if s2 and s3 then
		     nmc = sub(line, s2+1, s3-1)
		  end
          if s3 and s4 then
		     if sub(line, s3+1, s4-1) then
			    if tonumber(sub(line, s3+1, s4-1)) then
		           nscr = string.format('%09d', tonumber(sub(line, s3+1, s4-1)) )
				end
			 end
		  end
		  if s7 then
--15-04-2025 09:45;178377;5435;000335977;H;A245 - USTP VICTOR HUGO (Fermée le 31/12/2024);04-01-2025 01 37-06-01-2025 09 20;NUM_SEJ H=000359362,
             nsconf = sub(line, s7+11, s7+19)
		  end
		  if nmc ~= nmc_old then
		     --alimentation table correctifs en évitant les doublons
			 table.insert(num_mesure_corr, nmc )
			 table.insert(num_sejour_corr, nscr )
			 table.insert(num_sejour_conforme, nsconf )
			 nmc_old = nmc
		  end
	      --p0 = p+size_eol
		  p0 = p+1
       else
	      break
       end
 end
 print(#num_mesure_corr .. " mesures a corriger.")
 for i=1,#num_mesure_corr do
     print("Mesure " .. num_mesure_corr[i] .. ", sejour non conforme " .. num_sejour_corr[i] .. ", sejour conforme = " .. num_sejour_conforme[i])
 end
 
 

 st="Operations de chargement des donnees terminees !!! "
 fltk:fl_alert(st)
 --debut correctifs
 
 
-- os.exit(0)
correctifs()
save_modifs()

Fl:run()
